class MyDecorator:
    def __init__(self, *args, **kwargs):
        pass

    def __call__(self, func):
        # Внутри метода __call__ создаем обертку (wrapper), которая принимает все аргументы, которые были переданы в функцию, декорированную этим декоратором
        def wrapper(*args, **kwargs):
            # Выводим сообщение о том, что декоратор запущен перед выполнением функции
            print(f"Декоратор запущен перед выполнением функции {func.__name__}")
            # Вызываем функцию, которую декорируем, передавая ей все аргументы, которые были переданы в нее
            result = func(*args, **kwargs)
            # Выводим сообщение о том, что декоратор запущен после выполнения функции
            print(f"Декоратор запущен после выполнения функции {func.__name__}")
            # Возвращаем результат выполнения функции
            return result

        # Возвращаем обертку в качестве результата вызова декоратора
        return wrapper


# Применяем декоратор к функциям function1 и function2
@MyDecorator()
def function1():
    # Выполняем код функции
    print("Выполняется функция function1")

@MyDecorator()
def function2():
    # Выполняем код функции
    print("Выполняется функция function2")

# Вызываем функции, которые были декорированы этим декоратором
function1()
function2()